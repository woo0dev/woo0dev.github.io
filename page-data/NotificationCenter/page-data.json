{"componentChunkName":"component---src-templates-blog-template-js","path":"/NotificationCenter/","result":{"data":{"cur":{"id":"398f4221-3752-5668-987a-f093ba5df437","html":"<h1 id=\"notification\" style=\"position:relative;\"><a href=\"#notification\" aria-label=\"notification permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Notification</h1>\n<p>Notification Center를 통해 등록된 모든 Observer에게 정보를 브로드캐스트하는 컨테이너.</p>\n<h1 id=\"notificationcenter-동작-방식\" style=\"position:relative;\"><a href=\"#notificationcenter-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"notificationcenter 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NotificationCenter 동작 방식</h1>\n<p>특정 객체가 NotificationCenter에 등록된 Event를 발생시키면 해당 Event를 처리할 것이라고 등록된 Observer들이 Event에 대한 행동을 취하는 것이 NotificationCenter가 동작하는 방식이다. 이렇게 특정 객체가 Event를 발생시키는 것을 Post라고 한다.</p>\n<ul>\n<li>Listener (observer) : notifications를 감지</li>\n<li>Sender : 필요할 때 notifications 를 보내주는 역할</li>\n<li>itself : notification center 그 자체.</li>\n</ul>\n<p>Observer가 관찰 시작 → 작업이 발생하면 Sender가 Post → Observer selector 실행</p>","excerpt":"Notification Notification Center를 통해 등록된 모든 Observer에게 정보를 브로드캐스트하는 컨테이너. NotificationCenter 동작 방식 특정 객체가 NotificationCenter에 등록된 Event를 발생시키면 해당 Event를 처리할 것이라고 등록된 Observer들이 Event에 대한 행동을 취하는 것이 NotificationCenter가 동작하는 방식이다. 이렇게 특정 객체가 Event를 발생시키는 것을 Post라고 한다. Listener (observer) : notifications를 감지 Sender : 필요할 때 notifications 를 보내주는 역할 itself : notification center 그 자체. Observer가 관찰 시작 → 작업이 발생하면 Sender가 Post → Observer selector 실행","frontmatter":{"date":"October 21, 2021","title":"NotificationCenter 동작 방식과 활용 방안","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/NotificationCenter/"}},"next":{"id":"46839cd1-209e-5b5b-95fe-772b645767f6","html":"<h1 id=\"delegate란\" style=\"position:relative;\"><a href=\"#delegate%EB%9E%80\" aria-label=\"delegate란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Delegate란?</h1>\n<p>Delegate 란 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에게 위임하는 것이다.\n객체의 행동을 단순화 시키고 객체간 결합성을 최소화하는 장점이 있다.</p>\n<h1 id=\"retain\" style=\"position:relative;\"><a href=\"#retain\" aria-label=\"retain permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Retain</h1>\n<p>Retain cycle은 메모리가 해제되지 않고 유지되어 누수가 생기는 현상을 말하며 두 객체간의 참조가 강한 순환참조가 생겨 메모리에서 해제되지 않는 현상이다.\n따라서 Delegate 또한 객체간의 참조가 이루어 지기 때문에 retain cycle 현상이 발생할 수 있다.</p>","frontmatter":{"date":"October 20, 2021","title":"Delegate란 무언인가 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/delegate-retain/"}},"prev":{"id":"109d22d4-e1b8-554f-80f1-1ec9224a7e95","html":"<h1 id=\"swiftui란\" style=\"position:relative;\"><a href=\"#swiftui%EB%9E%80\" aria-label=\"swiftui란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SwiftUI란?</h1>\n<p>공식사이트에서는 “SwiftUI는 최소한의 코드만으로 Swift의 성능을 사용하여 모든 Apple 플랫폼에서 사용할 수 있는 앱을 개발 가능하다” 라고 나오지만 어떤 것인지 더 자세히 공부하기 위해 포스팅을 해보려고 한다.</p>\n<p>먼저 SwiftUI는 UIKit 위에서 빌드되는 프레임워크로 선언형 방식의 구조를 가지고 있다.\nSwiftUI 프로젝트를 생성하면 SceneDelegate.swift, ContentView.swift, Preview Content라는 폴터가 생기는데 이것들은 무엇일까.</p>\n<p>SceneDelegate는 멀티 윈도우 같은 기능을 지원하기 위해 Delegate이다. AppDelegate와는 달리 각 화면의 인스턴스 단위로 작동시킬 수 있다.</p>\n<p>ContentView는 제일 먼저 출력되는 View로 SceneDelegate에 Scene 메서드에 선언되어 있다.</p>\n<p>Preview Content는 Xcode에서 Simulator 없이 미리보기 화면을 제공하는 Canvas기능에서 사용되는 데이터들을 위한 Assets이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">import</span> <span class=\"token builtin\">SwiftUI</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token builtin\">ContentView</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">View</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">var</span> body<span class=\"token punctuation\">:</span> <span class=\"token keyword\">some</span> <span class=\"token builtin\">View</span> <span class=\"token punctuation\">{</span>\n        \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>프로젝트 생성시 자동으로 생성되는 ContentView의 모습이다.\nSwiftUI가 선언되어 있고 ContentView라는 구조체가 선언되어 있는 모습을 확인할 수 있다. 이 구조체는 View를 상속받아 View의 역할을 한다는 것을 알 수 있다.\n조금 특이한 것은 some이라는 키워드인데 특정한 조건을 만족하는 제네릭 타입의 View라고 한다.\nSwiftUI의 View에는 반드시 body 변수가 있어야하며 최상위 View 역할을 한다.</p>","frontmatter":{"date":"November 24, 2021","title":"SwiftUI 시작하기","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/SwiftUI-structure/"}},"site":{"siteMetadata":{"siteUrl":"https://woo0dev.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/NotificationCenter/","nextSlug":"/delegate-retain/","prevSlug":"/SwiftUI-structure/"}},"staticQueryHashes":["1073350324","2938748437"]}
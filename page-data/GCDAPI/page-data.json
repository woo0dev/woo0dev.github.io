{"componentChunkName":"component---src-templates-blog-template-js","path":"/GCDAPI/","result":{"data":{"cur":{"id":"781a5e85-4732-5588-9f83-382773863a9f","html":"<h1 id=\"gcdgrand-central-dispatch란\" style=\"position:relative;\"><a href=\"#gcdgrand-central-dispatch%EB%9E%80\" aria-label=\"gcdgrand central dispatch란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GCD(Grand Central Dispatch)란?</h1>\n<p>Background에서 Thread를 관리하면서 동시적으로 작업을 실행시키는 낮은 수준의 API를 제공하는 라이브러리이며,멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 기술이다.</p>\n<h3 id=\"gcd의-동작-방식\" style=\"position:relative;\"><a href=\"#gcd%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"gcd의 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GCD의 동작 방식</h3>\n<p>작업단위는 Block(Swift에서는 Closure)이라 불리며, DispatchQueue가 이 Block들을 관리한다.\nGDC는 각 어플리케이션에서 생성된 DispatchQueue를 읽는 멀티코어 실행엔진을 가지고 있으며, 이것이 Queue에 등록된 각 작업을 꺼내 Thread에 할당하고 개발자는 내부 동작을 자세히 알 필요 없이 Queue에 작업을 넘기기만 하면 되서, Thread를 직접 생성하고 관리하는 것에 비해 관리 용이성과, 이식성, 성능 증가하게 되었습니다.\nApple 공식 문서에서도 Thread 대신 GCD를 권장한다.  </p>\n<h3 id=\"dispatchqueue\" style=\"position:relative;\"><a href=\"#dispatchqueue\" aria-label=\"dispatchqueue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DispatchQueue</h3>\n<ul>\n<li>GCD는 App이 Block 객체 형태로 작업을 전송할 수 있는 FIFO Queue를 제공하고 관리한다.</li>\n<li>Queue에 전달된 작업은 시스템이 전적으로 관리하는 Thread pool에서 실행된다.</li>\n<li>DispatchQueue는 2개의 Type(Serial / Concurrent)으로 구분되며 둘 모두 FIFO 순서로 처리된다.</li>\n<li>App을 실행하면 시스템이 자동으로 MainThread 위에서 작동하는 Serial Queue를 만들어서 작업을 수행하고, 그 외에 추가적으로 여러 개의 Concurrent Queue를 만들어서 Queue를 관리한다.</li>\n<li>각 작업은 동기(sync) 방식과 비동기(async) 방식으로 실행 가능하지만 Serial Queue에서는 async만 사용 가능하다.  </li>\n</ul>\n<h4 id=\"serial-queue\" style=\"position:relative;\"><a href=\"#serial-queue\" aria-label=\"serial queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serial Queue</h4>\n<ul>\n<li>Serial Queue는 Queue에 추가된 순서대로 한번에 하나의 task를 실행한다.  </li>\n</ul>\n<h4 id=\"concurren-queue\" style=\"position:relative;\"><a href=\"#concurren-queue\" aria-label=\"concurren queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concurren Queue</h4>\n<ul>\n<li>Concurrent Queue는 동시에 하나 이상의 task를 실행하지만 Queue에 추가됐을 때에 추가된 순서대로 작업을 계속 진행한다.</li>\n</ul>","excerpt":"GCD(Grand Central Dispatch)란? Background에서 Thread를 관리하면서 동시적으로 작업을 실행시키는 낮은 수준의 API를 제공하는 라이브러리이며,멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 기술이다. GCD의 동작 방식 작업단위는 Block(Swift에서는 Closure)이라 불리며, DispatchQueue가 이 Block들을 관리한다.\nGDC는 각 어플리케이션에서 생성된 DispatchQueue를 읽는 멀티코어 실행엔진을 가지고 있으며, 이것이 Queue에 등록된 각 작업을 꺼내 Thread에 할당하고 개발자는 내부 동작을 자세히 알 필요 없이 Queue에 작업을 넘기기만 하면 되서, Thread를 직접 생성하고 관리하는 것에 비해 관리 용이성과, 이식성, 성능 증가하게 되었습니다.\nApple 공식 문서에서도 Thread 대신 GCD를 권장한다.   DispatchQueue GCD는 App이 Bloc…","frontmatter":{"date":"October 14, 2021","title":"GCD API의 동작 방식과 필요성","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/GCDAPI/"}},"next":{"id":"593c4b7d-245e-54c1-bb1f-e2b963c575a6","html":"<h1 id=\"nsoperationqueue와-gcd-queue의-차이점\" style=\"position:relative;\"><a href=\"#nsoperationqueue%EC%99%80-gcd-queue%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"nsoperationqueue와 gcd queue의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NSOperationQueue와 GCD Queue의 차이점</h1>\n<h2 id=\"ios의-멀티스레딩-방법\" style=\"position:relative;\"><a href=\"#ios%EC%9D%98-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"ios의 멀티스레딩 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>iOS의 멀티스레딩 방법</h2>\n<ul>\n<li>NSOperationQueue : Obj-c 기반의 high-level API</li>\n<li>GCD Queue : C 기반의 row-level API</li>\n</ul>\n<h2 id=\"nsoperationqueue\" style=\"position:relative;\"><a href=\"#nsoperationqueue\" aria-label=\"nsoperationqueue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NSOperationQueue</h2>\n<ul>\n<li>NSOperation 객체의 우선순위 및 준비 상태에 따라 대기열에 있는 객체를 실행한다. Operation Queue에 추가된 작업은 작업이 완료될 때까지 대기열에 남아 있다. 작업이 추가된 후에는 대기열에서 직접 제거할 수 없다.</li>\n<li>모든 작업이 끝나지 않은 상태에서 Opertion queue를 중지시키면 메모리 릭이 발생할 수 있다.</li>\n<li>GCD에서는 할 수 없는 기능들(재개, 취소, 중지)을 제공하지만 구현이 복잡하고 무겁다.</li>\n<li>NSOperations, NSOperationQueue를 사용할 때 오버헤드가 발생한다.</li>\n<li>\n<p>KVO(Key-Value Observing) 사용이 가능하다. (GCD는 불가)</p>\n<ul>\n<li>operations(read only) : 현재 큐에 있는 작업들</li>\n<li>operationCount(read only) : 현재 큐에 있는 작업의 개수</li>\n<li>maxConcurrentOperationCount(readable and writable) : 큐에서 동시에 실행할 수 있는 작업의 최대 개수</li>\n<li>suspended(readable and writable) : 실행 작업을 적극적으로 스케줄링하고 있는지 여부에 대한 Boolean 값</li>\n<li>name(readable and writable) : operationQueue의 이름</li>\n</ul>\n</li>\n<li>\n<p>작업 간의 의존성</p>\n<ul>\n<li>어떤 작업을 다른 작업이 성공적으로 수행된 후에 실행할 수 있게 하는 작업의 계층을 만들 수 있다.  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"gcdgrand-central-dispatch-queue-dispatch-queue\" style=\"position:relative;\"><a href=\"#gcdgrand-central-dispatch-queue-dispatch-queue\" aria-label=\"gcdgrand central dispatch queue dispatch queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GCD(Grand Central Dispatch) Queue (Dispatch Queue)</h2>\n<ul>\n<li>동시성 모델을 매우 간단하게 사용할 수 잇는 low-level C 기반 API</li>\n<li>앱의 메인 스레드 또는 백그라운드 스레드에서 작업의 실행을 직렬 또는 동시에 관리하는 객체이다.</li>\n<li>\n<p>작업 항목을 동기 또는 비동기적으로 예약한다.</p>\n<ul>\n<li>동기적 : 여러가지 작업을 순서대로 실행한다.</li>\n<li>비동기적 : 모든 동기 작업이 완료되기 전에 추가 스레드의 작업을 비동기로 실행해서 작업을 병렬적으로 수행하는 방식이다.</li>\n</ul>\n</li>\n<li>메인 큐에서 작업 항목을 동기적으로 실행하면 교착 상태가 발생할 수 있다.</li>\n</ul>","frontmatter":{"date":"October 13, 2021","title":"NSOperationQueue와 GCD Queue의 차이점","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/NSOperation-GCD/"}},"prev":{"id":"e0c510df-43bf-5b1a-bd4f-66d23c631b58","html":"<h1 id=\"uikit\" style=\"position:relative;\"><a href=\"#uikit\" aria-label=\"uikit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>UIKit</h1>\n<p>UI(User Interface) Kit Framework는 사용자 인터페이스를 관리하고, 이벤트를 처리하는게 주 목적인 Framework이다.\nmacOS에서는 Application Kit(AppKit) Framework를 사용했었지만 iOS로 넘어오면서 UIKit으로 대체되었다.\nUIKit에서 주로 처리하는 사용자 이벤트로는 제스처 처리, 애니메이션, 그림 그리기, 이미지 처리, 텍스트 처리 등이 있다.\n또한 테이블뷰, 슬라이더, 버튼, 텍스트 필트, Alert 창 등 Application의 화면을 구성하는 요소도 포함된다.\nUIViewController, UIView, UIAlertController 등 앞에 UI가 붙는 클래스들을 사용하려면 반드시 UIKit을 상속해야한다.</p>","frontmatter":{"date":"October 15, 2021","title":"iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/iOS-UserInterface-Framework/"}},"site":{"siteMetadata":{"siteUrl":"https://woo0dev.github.io","comments":{"utterances":{"repo":"woo0dev/woo0dev.github.io"}}}}},"pageContext":{"slug":"/GCDAPI/","nextSlug":"/NSOperation-GCD/","prevSlug":"/iOS-UserInterface-Framework/"}},"staticQueryHashes":["1073350324","2938748437"]}
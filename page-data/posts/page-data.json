{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","categories":["All","iOS","git","iOSgit"],"edges":[{"node":{"id":"109d22d4-e1b8-554f-80f1-1ec9224a7e95","excerpt":"SwiftUI란? 공식사이트에서는 “SwiftUI는 최소한의 코드만으로 Swift의 성능을 사용하여 모든 Apple 플랫폼에서 사용할 수 있는 앱을 개발 가능하다” 라고 나오지만 어떤 것인지 더 자세히 공부하기 위해 포스팅을 해보려고 한다. 먼저 SwiftUI는 UIKit 위에서 빌드되는 프레임워크로 선언형 방식의 구조를 가지고 있다.\nSwiftUI 프로젝트를 생성하면 SceneDelegate.swift, ContentView.swift, Preview Content라는 폴터가 생기는데 이것들은 무엇일까. SceneDelegate는 멀티 윈도우 같은 기능을 지원하기 위해 Delegate이다. AppDelegate와는 달리 각 화면의 인스턴스 단위로 작동시킬 수 있다. ContentView는 제일 먼저 출력되는 View로 SceneDelegate에 Scene 메서드에 선언되어 있다. Preview Content는 Xcode에서 Simulator 없이 미리보기 화면을 제공하는 Canv…","fields":{"slug":"/SwiftUI-structure/"},"frontmatter":{"categories":"iOS","title":"SwiftUI 시작하기","date":"November 24, 2021"}},"next":{"fields":{"slug":"/NotificationCenter/"}},"previous":null},{"node":{"id":"398f4221-3752-5668-987a-f093ba5df437","excerpt":"Notification Notification Center를 통해 등록된 모든 Observer에게 정보를 브로드캐스트하는 컨테이너. NotificationCenter 동작 방식 특정 객체가 NotificationCenter에 등록된 Event를 발생시키면 해당 Event를 처리할 것이라고 등록된 Observer들이 Event에 대한 행동을 취하는 것이 NotificationCenter가 동작하는 방식이다. 이렇게 특정 객체가 Event를 발생시키는 것을 Post라고 한다. Listener (observer) : notifications를 감지 Sender : 필요할 때 notifications 를 보내주는 역할 itself : notification center 그 자체. Observer가 관찰 시작 → 작업이 발생하면 Sender가 Post → Observer selector 실행","fields":{"slug":"/NotificationCenter/"},"frontmatter":{"categories":"iOS","title":"NotificationCenter 동작 방식과 활용 방안","date":"October 21, 2021"}},"next":{"fields":{"slug":"/delegate-retain/"}},"previous":{"fields":{"slug":"/SwiftUI-structure/"}}},{"node":{"id":"46839cd1-209e-5b5b-95fe-772b645767f6","excerpt":"Delegate란? Delegate 란 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에게 위임하는 것이다.\n객체의 행동을 단순화 시키고 객체간 결합성을 최소화하는 장점이 있다. Retain Retain cycle은 메모리가 해제되지 않고 유지되어 누수가 생기는 현상을 말하며 두 객체간의 참조가 강한 순환참조가 생겨 메모리에서 해제되지 않는 현상이다.\n따라서 Delegate 또한 객체간의 참조가 이루어 지기 때문에 retain cycle 현상이 발생할 수 있다.","fields":{"slug":"/delegate-retain/"},"frontmatter":{"categories":"iOS","title":"Delegate란 무언인가 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.","date":"October 20, 2021"}},"next":{"fields":{"slug":"/FoundationKit/"}},"previous":{"fields":{"slug":"/NotificationCenter/"}}},{"node":{"id":"b35fce32-172c-5b1a-a05f-63b6a9c09597","excerpt":"Foundation이란? Apple에서 제공하는 기본 프레임워크인 코코아 터치 프레임워크에 포한되어 있는 프레임워크이다. Foundation 프레임워크는 데이터 스토리지 및 지속성, 텍스트 처리, 날짜 및 시간 계산, 정렬 및 필터링, 네트워킹을 포함한 애플리케이션과 프레임워크에 대한 기본 기능 계층을 제공한다. Foundation에서 정의한 클래스, 프로토콜, 데이터 유형은 MacOS, iOS, watchOS, tvOS SDK 전반에 걸쳐 사용된다. 포함된 클래스 Collections(Sorting, Type…) Strings  Dates and times  URLs(Networking)  XML data  Ports and sockets  Notification Center interaction","fields":{"slug":"/FoundationKit/"},"frontmatter":{"categories":"iOS","title":"Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있을까?","date":"October 19, 2021"}},"next":{"fields":{"slug":"/iOS-UserInterface-Framework/"}},"previous":{"fields":{"slug":"/delegate-retain/"}}},{"node":{"id":"e0c510df-43bf-5b1a-bd4f-66d23c631b58","excerpt":"UIKit UI(User Interface) Kit Framework는 사용자 인터페이스를 관리하고, 이벤트를 처리하는게 주 목적인 Framework이다.\nmacOS에서는 Application Kit(AppKit) Framework를 사용했었지만 iOS로 넘어오면서 UIKit으로 대체되었다.\nUIKit에서 주로 처리하는 사용자 이벤트로는 제스처 처리, 애니메이션, 그림 그리기, 이미지 처리, 텍스트 처리 등이 있다.\n또한 테이블뷰, 슬라이더, 버튼, 텍스트 필트, Alert 창 등 Application의 화면을 구성하는 요소도 포함된다.\nUIViewController, UIView, UIAlertController 등 앞에 UI가 붙는 클래스들을 사용하려면 반드시 UIKit을 상속해야한다.","fields":{"slug":"/iOS-UserInterface-Framework/"},"frontmatter":{"categories":"iOS","title":"iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?","date":"October 15, 2021"}},"next":{"fields":{"slug":"/GCDAPI/"}},"previous":{"fields":{"slug":"/FoundationKit/"}}},{"node":{"id":"781a5e85-4732-5588-9f83-382773863a9f","excerpt":"GCD(Grand Central Dispatch)란? Background에서 Thread를 관리하면서 동시적으로 작업을 실행시키는 낮은 수준의 API를 제공하는 라이브러리이며,멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 기술이다. GCD의 동작 방식 작업단위는 Block(Swift에서는 Closure)이라 불리며, DispatchQueue가 이 Block들을 관리한다.\nGDC는 각 어플리케이션에서 생성된 DispatchQueue를 읽는 멀티코어 실행엔진을 가지고 있으며, 이것이 Queue에 등록된 각 작업을 꺼내 Thread에 할당하고 개발자는 내부 동작을 자세히 알 필요 없이 Queue에 작업을 넘기기만 하면 되서, Thread를 직접 생성하고 관리하는 것에 비해 관리 용이성과, 이식성, 성능 증가하게 되었습니다.\nApple 공식 문서에서도 Thread 대신 GCD를 권장한다.   DispatchQueue GCD는 App이 Bloc…","fields":{"slug":"/GCDAPI/"},"frontmatter":{"categories":"iOS","title":"GCD API의 동작 방식과 필요성","date":"October 14, 2021"}},"next":{"fields":{"slug":"/NSOperation-GCD/"}},"previous":{"fields":{"slug":"/iOS-UserInterface-Framework/"}}},{"node":{"id":"593c4b7d-245e-54c1-bb1f-e2b963c575a6","excerpt":"NSOperationQueue와 GCD Queue의 차이점 iOS의 멀티스레딩 방법 NSOperationQueue : Obj-c 기반의 high-level API GCD Queue : C 기반의 row-level API NSOperationQueue NSOperation 객체의 우선순위 및 준비 상태에 따라 대기열에 있는 객체를 실행한다. Operation Queue에 추가된 작업은 작업이 완료될 때까지 대기열에 남아 있다. 작업이 추가된 후에는 대기열에서 직접 제거할 수 없다. 모든 작업이 끝나지 않은 상태에서 Opertion queue를 중지시키면 메모리 릭이 발생할 수 있다. GCD에서는 할 수 없는 기능들(재개, 취소, 중지)을 제공하지만 구현이 복잡하고 무겁다. NSOperations, NSOperationQueue를 사용할 때 오버헤드가 발생한다. KVO(Key-Value Observing) 사용이 가능하다. (GCD는 불가) operations(read only) : …","fields":{"slug":"/NSOperation-GCD/"},"frontmatter":{"categories":"iOS","title":"NSOperationQueue와 GCD Queue의 차이점","date":"October 13, 2021"}},"next":{"fields":{"slug":"/in-Active/"}},"previous":{"fields":{"slug":"/GCDAPI/"}}},{"node":{"id":"acdad3c9-eba8-5f6d-8f30-c90325ffe5a6","excerpt":"앱이 In-Active 상태가 되는 시나리오를 설명하시오. Foreground In-Active와 Active를 합쳐서 Foreground라고 한다. In-Activeg App이 실행 중이지만 이벤트를 받지 않는 상태 시나리오 사용자가 앱을 실행했을 때 Not Running -> In-Active -> Active 앱 실행 도중 홈 버튼을 눌렀을 때 Active -> In-Active -> Background 앱을 다시 켰을 때 Background -> Active 앱이 백그라운드에 있다가 Suspended 상태로 전이 Active -> In-Active -> Background -> Suspended","fields":{"slug":"/in-Active/"},"frontmatter":{"categories":"iOSgit","title":"앱이 In-Active 상태가 되는 시나리오","date":"October 12, 2021"}},"next":{"fields":{"slug":"/scenedelegate/"}},"previous":{"fields":{"slug":"/NSOperation-GCD/"}}},{"node":{"id":"70c417e4-a915-507d-97bd-36fe19f7aa6c","excerpt":"SceneDelegate란? SceneDelegate는 Xcode11부터 iOS App 탬플릿 생성 시 자동으로 추가된다. iOS13 이상부터는 SceneDelegate가 AppDelegate의 일부 역할을 담당한다. 여기서 중요한 점은 window의 개념이 Scene 개념으로 대체된다는 것이다. 앱에 둘 이상의 Scene이 있을 수 있으며, 앱의 사용자 인터페이스 및 콘텐츠의 배경으로 사용된다. Scene이 있는 하나의 앱을 갖는 개념은 iOS 및 iPadOS에서 다중 창\u001c앱을 빌드할 수 있습니다.   자동으로 생성되는 SceneDelegate에는 active, resign and disconnect와 같은 친숙한 라이프사이클\u001c이벤트가 있습니다.\nSceneDelegate는 delegate를 사용하며 일반적으로 모든 장면에 응답한다는 점에 유의해야합니다. 하나의 Delegate를 정의하여 앱의 모든 Scene에서 사용합니다.   SceneDelegate에 있는 함수들 SceneDe…","fields":{"slug":"/scenedelegate/"},"frontmatter":{"categories":"iOS","title":"SceneDelegate란?","date":"October 09, 2021"}},"next":{"fields":{"slug":"/delegate-method/"}},"previous":{"fields":{"slug":"/in-Active/"}}},{"node":{"id":"cf6bbb2b-5acd-534d-b0cb-5f451e0685a9","excerpt":"애플리케이션이 실행된 직후 사용자의 화면에 보여지기 직전에 호출 애플리케이션이 최초 실행될 때 호출되는 메소드 애플리케이션이 InActive 상태로 전환되기 직전에 호출  task 일시정지, 타이머 비활성화, 일시정지(게임) 애플리케이션이 백그라운드 상태로 전환된 직후 호출 애플리케이션이 Active 상태가 되기 직전, 화면에 보여지기 직전에 호출 애플리케이션이 Active 상태로 전환된 직후 호출 애플리케이션이 종료되기 직전에 호출","fields":{"slug":"/delegate-method/"},"frontmatter":{"categories":"iOS","title":"iOS App 상황별 Delegate Method","date":"October 05, 2021"}},"next":{"fields":{"slug":"/app-state/"}},"previous":{"fields":{"slug":"/scenedelegate/"}}},{"node":{"id":"f060144e-e7da-5710-bc39-8bf446a2c626","excerpt":"iOS App 상태별 제약사항에 대해 알아보자 not Running : 앱이 실행되지 않은 상태   Foreground : App이 실행되어 클라이언트에게 보여지고 있는 상태 Inactive : 앱이 실행중이지만 아직 아무런 이벤트를 받지 않은 상태 (Foreground 상태에서 전화가 왔을 때, 잠금상태, 멀티태스킹 스크린에서는 Inactive 상태를 가진다.) Active : 앱이 실행중이며 현재 이벤트를 받고 있고 발생한 상태\u001f Background : 앱이 백그라운드에 있는 상태지만 여전히 실행중인 상태 Suspened : 앱이 백그라운드에 있고 실행되는 코드가 없는 상태 (App은 여전히 메모리에 존재하며 Suspened 상태가 될 당시의 상태를 저장하고 있지만, CPU나 배터리를 소모하지 않습니다. 언제든지 메모리 부족등의 이유로 종료됨.) 앱의 상태별 제약사항 Foreground mode는 메모리 및 기타 시스템 리소스에 높은 우선순위를 가지며 시스템은 이러한 리소스를 …","fields":{"slug":"/app-state/"},"frontmatter":{"categories":"iOS","title":"iOS App 상태별 제약사항","date":"October 02, 2021"}},"next":{"fields":{"slug":"/bounds-frame-study/"}},"previous":{"fields":{"slug":"/delegate-method/"}}},{"node":{"id":"9ba76d1f-30ea-56a5-b746-48dbdac2cf0e","excerpt":"Bounds와 Frame Bounds와 Frame의 차이를 공부하기 전에 먼저 Bounds와 Frame이 뭔지 알아보자 Bounds와 Frame은 UIView의 instance property다. Bounds와 Frame 둘 다 CGRect Type이기 때문에 origin과 size를 가진 사각형으로 그려진다. Frame SuperView(상위뷰)의 좌표시스템 안에서 View의 origin과 size를 나타낸다. 여기서 상위뷰란 한단계 상위뷰를 의미한다. 예를 들어 Frame으로 정의된 View의 origin이나 size를 출력하면 해당 View의 상위뷰 origin과 size가 출력된다. 또한 origin과 size를 수정했을 때도 마찬가지로 상위뷰의 origin과 size가 수정된다. Bounds View의 위치와 크기를 자기 자신의 좌표시스템안에서 origin와 size를 나타낸다. 예를 들어 Bounds로 정의된 View의 origin이나 size를 출력하면 해당 View의…","fields":{"slug":"/bounds-frame-study/"},"frontmatter":{"categories":"iOS","title":"Bounds와 Frame의 차이","date":"September 30, 2021"}},"next":{"fields":{"slug":"/development-without-device/"}},"previous":{"fields":{"slug":"/app-state/"}}},{"node":{"id":"0b08f52a-f4a2-5495-a6aa-7613f485fc87","excerpt":"개발할 때 디바이스가 없으면 할 수 없는 것 하드웨어 가속도 센서, 가압계 센서, 주변광 센서, GPS 센서 기능을 사용할 수 없다. 마우스로 시뮬레이터의 터치를 하기 때문에 두 소가락으로 하는 줌인 줌아웃 등의 기능을 테스트 할 수 없다. 카메라를 사용할 수 없다. 마이크를 사용할 수 없다. 전화기능을 사용할 수 없다. API Apple의 푸시 알림 받기와 보내기 기능을 사용할 수 없다. 사진, 연락처, 캘린더에 엑세스하기 위해 개인 정보 보호 알림을 지원하지 않는다. Handoff 기능을 사용할 수 없다. MessageUI 기능을 사용할 수 없다. 그 외 맥의 성능이 아이폰의 성능보다 훨씬 뛰어나 CPU나 메모리 부담이 얼마나 되는지 알 수 없다. 내트워크 속도 태스트를 할 수 없다. 페이스 아이디는 직접 얼굴 인식은 안되지만 인식됨, 안됨 처리는 할 수 있다.","fields":{"slug":"/development-without-device/"},"frontmatter":{"categories":"iOS","title":"iOS 개발할 때 실제 디바이스가 없으면 할 수 없는 것","date":"September 30, 2021"}},"next":{"fields":{"slug":"/git-study/"}},"previous":{"fields":{"slug":"/bounds-frame-study/"}}},{"node":{"id":"0710e72b-bb85-5941-8a90-c32cd1733093","excerpt":"Git 정리하기 Git은 버전을 편리하게 관리할 수 있도록 도와주는 도구이다. 개인 뿐만 아니라 다른 사람과의 협업을 하는 경우에도 큰 도움이 된다. Git Tool GitHub DeskTop : commands에서 사용할 때 보다 사용할 수 있는 기능이 극히 제한적이다. Sourcetree : 다양한 기능을 사용할 수 있고, 전반적으로 많이 사용하고 있지만 역시 commands에서 사용할 수 있는 명령어보다 적다. GitKraken : UI가 화려한 Tool   Git 설치 여부 확인 방법 Git 설치 여부 확인하기 위해서는 터미널에서 git —version 명령어를 쳤을 때 버전이 나온다면 Git이 설치되어 있는 것이다. Git의 설정 정보 확인 방법 git을 설치하면 git에 대한 모든 설정들을 확인하려면 git config —list 명령어를 활용해 확인 할 수 있다. file로 확인하고 싶다면 git —global -e 명령어를 사용하면 된다. Git의 설정 정보를 특정 …","fields":{"slug":"/git-study/"},"frontmatter":{"categories":"git","title":"Git 정리","date":"September 29, 2021"}},"next":{"fields":{"slug":"/how-to-start-gatsby/"}},"previous":{"fields":{"slug":"/development-without-device/"}}},{"node":{"id":"8c36d57d-9137-5712-8dfa-7b8ec9e68336","excerpt":"내가 블로그를 시작하게 된 계기는 개발이 아닌 관련 공부를 할 때 정리를 하고 싶어서 여러가지 블로그를 찾아보다가 현재 사용중인 GitHub와 연동하여 사용할 수 있는 블로그 라이브러리인 Gatsby를 알게 되어 만들게 되었다. Gatsby로 블로그를 만들기 위해 처음에는 관련 테마를 찾아보고 맘에 드는 테마를 적용하여 만들기로 했다. 이제부터 내가 Gatsby 블로그를 만드는 과정을 소개한다. 원하는 테마의 Gatsby Clone Repository 생성(Repository명은 꼭 GitHubID.github.io) Your old repository’s clone URL에 getsby 테마의 repository url 넣기 cd Repository 주소 \nnpm install npm install gh-pages —save-dev npm run deploy git branch gh-pages Setting-Pages-Source Branch를 gh-pages로 설정 git br…","fields":{"slug":"/how-to-start-gatsby/"},"frontmatter":{"categories":"git","title":"Gatsby 테마로 GitHub Blog 만들기","date":"September 25, 2021"}},"next":null,"previous":{"fields":{"slug":"/git-study/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/NSOperation-GCD/","result":{"data":{"cur":{"id":"593c4b7d-245e-54c1-bb1f-e2b963c575a6","html":"<h1 id=\"nsoperationqueue와-gcd-queue의-차이점\" style=\"position:relative;\"><a href=\"#nsoperationqueue%EC%99%80-gcd-queue%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"nsoperationqueue와 gcd queue의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NSOperationQueue와 GCD Queue의 차이점</h1>\n<h2 id=\"ios의-멀티스레딩-방법\" style=\"position:relative;\"><a href=\"#ios%EC%9D%98-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9-%EB%B0%A9%EB%B2%95\" aria-label=\"ios의 멀티스레딩 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>iOS의 멀티스레딩 방법</h2>\n<ul>\n<li>NSOperationQueue : Obj-c 기반의 high-level API</li>\n<li>GCD Queue : C 기반의 row-level API</li>\n</ul>\n<h2 id=\"nsoperationqueue\" style=\"position:relative;\"><a href=\"#nsoperationqueue\" aria-label=\"nsoperationqueue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NSOperationQueue</h2>\n<ul>\n<li>NSOperation 객체의 우선순위 및 준비 상태에 따라 대기열에 있는 객체를 실행한다. Operation Queue에 추가된 작업은 작업이 완료될 때까지 대기열에 남아 있다. 작업이 추가된 후에는 대기열에서 직접 제거할 수 없다.</li>\n<li>모든 작업이 끝나지 않은 상태에서 Opertion queue를 중지시키면 메모리 릭이 발생할 수 있다.</li>\n<li>GCD에서는 할 수 없는 기능들(재개, 취소, 중지)을 제공하지만 구현이 복잡하고 무겁다.</li>\n<li>NSOperations, NSOperationQueue를 사용할 때 오버헤드가 발생한다.</li>\n<li>\n<p>KVO(Key-Value Observing) 사용이 가능하다. (GCD는 불가)</p>\n<ul>\n<li>operations(read only) : 현재 큐에 있는 작업들</li>\n<li>operationCount(read only) : 현재 큐에 있는 작업의 개수</li>\n<li>maxConcurrentOperationCount(readable and writable) : 큐에서 동시에 실행할 수 있는 작업의 최대 개수</li>\n<li>suspended(readable and writable) : 실행 작업을 적극적으로 스케줄링하고 있는지 여부에 대한 Boolean 값</li>\n<li>name(readable and writable) : operationQueue의 이름</li>\n</ul>\n</li>\n<li>\n<p>작업 간의 의존성</p>\n<ul>\n<li>어떤 작업을 다른 작업이 성공적으로 수행된 후에 실행할 수 있게 하는 작업의 계층을 만들 수 있다.  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"gcdgrand-central-dispatch-queue-dispatch-queue\" style=\"position:relative;\"><a href=\"#gcdgrand-central-dispatch-queue-dispatch-queue\" aria-label=\"gcdgrand central dispatch queue dispatch queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GCD(Grand Central Dispatch) Queue (Dispatch Queue)</h2>\n<ul>\n<li>동시성 모델을 매우 간단하게 사용할 수 잇는 low-level C 기반 API</li>\n<li>앱의 메인 스레드 또는 백그라운드 스레드에서 작업의 실행을 직렬 또는 동시에 관리하는 객체이다.</li>\n<li>\n<p>작업 항목을 동기 또는 비동기적으로 예약한다.</p>\n<ul>\n<li>동기적 : 여러가지 작업을 순서대로 실행한다.</li>\n<li>비동기적 : 모든 동기 작업이 완료되기 전에 추가 스레드의 작업을 비동기로 실행해서 작업을 병렬적으로 수행하는 방식이다.</li>\n</ul>\n</li>\n<li>메인 큐에서 작업 항목을 동기적으로 실행하면 교착 상태가 발생할 수 있다.</li>\n</ul>","excerpt":"NSOperationQueue와 GCD Queue의 차이점 iOS의 멀티스레딩 방법 NSOperationQueue : Obj-c 기반의 high-level API GCD Queue : C 기반의 row-level API NSOperationQueue NSOperation 객체의 우선순위 및 준비 상태에 따라 대기열에 있는 객체를 실행한다. Operation Queue에 추가된 작업은 작업이 완료될 때까지 대기열에 남아 있다. 작업이 추가된 후에는 대기열에서 직접 제거할 수 없다. 모든 작업이 끝나지 않은 상태에서 Opertion queue를 중지시키면 메모리 릭이 발생할 수 있다. GCD에서는 할 수 없는 기능들(재개, 취소, 중지)을 제공하지만 구현이 복잡하고 무겁다. NSOperations, NSOperationQueue를 사용할 때 오버헤드가 발생한다. KVO(Key-Value Observing) 사용이 가능하다. (GCD는 불가) operations(read only) : …","frontmatter":{"date":"October 13, 2021","title":"NSOperationQueue와 GCD Queue의 차이점","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/NSOperation-GCD/"}},"next":{"id":"acdad3c9-eba8-5f6d-8f30-c90325ffe5a6","html":"<h1 id=\"앱이-in-active-상태가-되는-시나리오를-설명하시오\" style=\"position:relative;\"><a href=\"#%EC%95%B1%EC%9D%B4-in-active-%EC%83%81%ED%83%9C%EA%B0%80-%EB%90%98%EB%8A%94-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4%EB%A5%BC-%EC%84%A4%EB%AA%85%ED%95%98%EC%8B%9C%EC%98%A4\" aria-label=\"앱이 in active 상태가 되는 시나리오를 설명하시오 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>앱이 In-Active 상태가 되는 시나리오를 설명하시오.</h1>\n<h2 id=\"foreground\" style=\"position:relative;\"><a href=\"#foreground\" aria-label=\"foreground permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Foreground</h2>\n<p>In-Active와 Active를 합쳐서 Foreground라고 한다.</p>\n<h2 id=\"in-activeg\" style=\"position:relative;\"><a href=\"#in-activeg\" aria-label=\"in activeg permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>In-Activeg</h2>\n<p>App이 실행 중이지만 이벤트를 받지 않는 상태</p>\n<h2 id=\"시나리오\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4\" aria-label=\"시나리오 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시나리오</h2>\n<ul>\n<li>\n<p>사용자가 앱을 실행했을 때</p>\n<ul>\n<li>Not Running -> In-Active -> Active</li>\n</ul>\n</li>\n<li>\n<p>앱 실행 도중 홈 버튼을 눌렀을 때</p>\n<ul>\n<li>Active -> In-Active -> Background</li>\n</ul>\n</li>\n<li>\n<p>앱을 다시 켰을 때</p>\n<ul>\n<li>Background -> Active</li>\n</ul>\n</li>\n<li>\n<p>앱이 백그라운드에 있다가 Suspended 상태로 전이</p>\n<ul>\n<li>Active -> In-Active -> Background -> Suspended</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"October 12, 2021","title":"앱이 In-Active 상태가 되는 시나리오","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/in-Active/"}},"prev":{"id":"781a5e85-4732-5588-9f83-382773863a9f","html":"<h1 id=\"gcdgrand-central-dispatch란\" style=\"position:relative;\"><a href=\"#gcdgrand-central-dispatch%EB%9E%80\" aria-label=\"gcdgrand central dispatch란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GCD(Grand Central Dispatch)란?</h1>\n<p>Background에서 Thread를 관리하면서 동시적으로 작업을 실행시키는 낮은 수준의 API를 제공하는 라이브러리이며,멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 기술이다.</p>\n<h3 id=\"gcd의-동작-방식\" style=\"position:relative;\"><a href=\"#gcd%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"gcd의 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GCD의 동작 방식</h3>\n<p>작업단위는 Block(Swift에서는 Closure)이라 불리며, DispatchQueue가 이 Block들을 관리한다.\nGDC는 각 어플리케이션에서 생성된 DispatchQueue를 읽는 멀티코어 실행엔진을 가지고 있으며, 이것이 Queue에 등록된 각 작업을 꺼내 Thread에 할당하고 개발자는 내부 동작을 자세히 알 필요 없이 Queue에 작업을 넘기기만 하면 되서, Thread를 직접 생성하고 관리하는 것에 비해 관리 용이성과, 이식성, 성능 증가하게 되었습니다.\nApple 공식 문서에서도 Thread 대신 GCD를 권장한다.  </p>\n<h3 id=\"dispatchqueue\" style=\"position:relative;\"><a href=\"#dispatchqueue\" aria-label=\"dispatchqueue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DispatchQueue</h3>\n<ul>\n<li>GCD는 App이 Block 객체 형태로 작업을 전송할 수 있는 FIFO Queue를 제공하고 관리한다.</li>\n<li>Queue에 전달된 작업은 시스템이 전적으로 관리하는 Thread pool에서 실행된다.</li>\n<li>DispatchQueue는 2개의 Type(Serial / Concurrent)으로 구분되며 둘 모두 FIFO 순서로 처리된다.</li>\n<li>App을 실행하면 시스템이 자동으로 MainThread 위에서 작동하는 Serial Queue를 만들어서 작업을 수행하고, 그 외에 추가적으로 여러 개의 Concurrent Queue를 만들어서 Queue를 관리한다.</li>\n<li>각 작업은 동기(sync) 방식과 비동기(async) 방식으로 실행 가능하지만 Serial Queue에서는 async만 사용 가능하다.  </li>\n</ul>\n<h4 id=\"serial-queue\" style=\"position:relative;\"><a href=\"#serial-queue\" aria-label=\"serial queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serial Queue</h4>\n<ul>\n<li>Serial Queue는 Queue에 추가된 순서대로 한번에 하나의 task를 실행한다.  </li>\n</ul>\n<h4 id=\"concurren-queue\" style=\"position:relative;\"><a href=\"#concurren-queue\" aria-label=\"concurren queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concurren Queue</h4>\n<ul>\n<li>Concurrent Queue는 동시에 하나 이상의 task를 실행하지만 Queue에 추가됐을 때에 추가된 순서대로 작업을 계속 진행한다.</li>\n</ul>","frontmatter":{"date":"October 14, 2021","title":"GCD API의 동작 방식과 필요성","categories":"iOS","author":"woo0dev","emoji":"🐻"},"fields":{"slug":"/GCDAPI/"}},"site":{"siteMetadata":{"siteUrl":"https://woo0dev.github.io","comments":{"utterances":{"repo":"woo0dev/woo0dev.github.io"}}}}},"pageContext":{"slug":"/NSOperation-GCD/","nextSlug":"/in-Active/","prevSlug":"/GCDAPI/"}},"staticQueryHashes":["1073350324","2938748437"]}